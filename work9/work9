解决方案1：固定缓冲区大小
固定缓冲区大小的实现方案，只需要控制服务器端和客户端发送和接收字节的（数组）长度相同即可。

优缺点分析
从以上代码可以看出，虽然这种方式可以解决粘包和半包的问题，但这种固定缓冲区大小的方式增加了不必要的数据传输，因为这种方式当发送的数据比较小时会使用空字符来弥补，所以这种方式就大大的增加了网络传输的负担，所以它也不是最佳的解决方案。


解决方案二：封装请求协议
这种解决方案的实现思路是将请求的数据封装为两部分：数据头+数据正文，在数据头中存储数据正文的大小，当读取的数据小于数据头中的大小时，继续读取数据，直到读取的数据长度等于数据头中的长度时才停止。

因为这种方式可以拿到数据的边界，所以也不会导致粘包和半包的问题，但这种实现方式的编码成本较大也不够优雅，因此不是最佳的实现方案，因此我们这里就略过，直接来看最终的解决方案吧。

解决方案三：特殊字符结尾，按行读取
以特殊字符结尾就可以知道流的边界了，因此也可以用来解决粘包和半包的问题，此实现方案是我们推荐最终解决方案。解决方案三：特殊字符结尾，按行读取
以特殊字符结尾就可以知道流的边界了，因此也可以用来解决粘包和半包的问题，此实现方案是我们推荐最终解决方案。

